/**
 *@file 01内联函数.cpp
 *@author chenshining
 *@version v1.0
 *@date 2023-08-02
 */
#include <iostream>
#include <vector>
#include <string>

using namespace std;

/**
 * C++中推荐使用内联函数替代宏代码片段
 * 1. 内联函数声明时 inline 关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求。意味着内联函数不可单独声明
 * 2. C++编译器可以将一个函数进行内联编译被 C++编译器内联编译的函数叫做内联函数
 * 内联函数在最终生成的代码中是没有定义的
 * C++编译器直接将函数体插入在函数调用的地方
 * 内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)
 * 3. C++编译器不一定准许函数的内联请求！
 * 内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型等）
 * 内联函数是对编译器的一种请求，因此编译器可能拒绝这种请求
 * 内联函数由 编译器处理，直接将编译后的函数体插入调用的地方
 * 宏代码片段 由预处理器处理， 进行简单的文本替换，没有任何编译过程
 * 4. 现代 C++编译器能够进行编译优化，因此一些函数即使没有 inline 声明，也可能被编译器
 * 内联编译
 * 另外，一些现代 C++编译器提供了扩展语法，能够对函数进行强制内联如：g++中的__attribute__((always_inline))属性
 * 5. C++中内联编译的限制：
 * 不能存在任何形式的循环语句
 * 不能存在过多的条件判断语句
 * 函数体不能过于庞大
 * 不能对函数进行取址操作
 * 函数内联声明必须在调用语句之前
 * 6. 总结：
 * 1）内联函数在编译时直接将函数体插入函数调用的地方
 * 2）inline 只是一种请求，编译器不一定允许这种请求
 * 3）内联函数省去了普通函数调用时压栈，跳转和返回的开销
 * */
#if(0)
#define MYFUNC(a, b) ((a) < (b) ? (a) : (b))     //带参数的宏定义
inline int myfunc(int a, int b){                   //内联函数
    return a < b ? a : b;
    }
int main(){
    int a = 1;
    int b = 3;
    int c = myfunc(++a, b); //a=2,b=3,c=2
    // int c = MYFUNC(++a, b); //a=3,b=3,c=3
    printf("a = %d\n", a);
    printf("b = %d\n", b);
    printf("c = %d\n", c);
    // system("pause");
    return 0;
}
#endif

// i++ 和 ++i的区别
